# 统计值为 1 的位元数

种群计数(population count)函数, 也常常被简写为 pop, popcnt 或 pcnt.

有一种"分治法"可以巧妙的计算这个值: 首先, 把邻近的两个位元值编组为 1 个位段, 将这两个位元的值相加, 把结果放到宽度为 2 的位段中, 然后把邻近的两个二元位段相加, 将结果放到宽度为 4 的位段中, 以此类推. 这种算法利用了"分而治之"的想法, 将一个大问题(统计 32 个位元中值为 1 的个数)化为两个小问题(统计 16 个位元中值为 1 的个数), 分别将其解决, 然后合并结果.

```no-highlight
| 1 0   1 1   1 1   0 0   0 1   1 0   0 0   1 1   0 1   1 1   1 1   1 0   1 1   1 1   1 1   1 1 |
| 0 1 | 1 0 | 1 0 | 0 0 | 0 1 | 0 1 | 0 0 | 1 0 | 0 1 | 1 0 | 1 0 | 0 1 | 1 0 | 1 0 | 1 0 | 1 0 |
| 0 0   1 1 | 0 0   1 0 | 0 0   1 0 | 0 0   1 0 | 0 0   1 1 | 0 0   1 1 | 0 1   0 0 | 0 1   0 0 |
| 0 0   0 0   0 1   0 1 | 0 0   0 0   0 1   0 0 | 0 0   0 0   0 1   1 0 | 0 0   0 0   1 0   0 0 |
| 0 0   0 0   0 0   0 0   0 0   0 0   1 0   0 1 | 0 0   0 0   0 0   0 0   0 0   0 0   1 1   1 0 |
| 0 0   0 0   0 0   0 0   0 0   0 0   0 0   0 0   0 0   0 0   0 0   0 0   0 0   0 1   0 1   1 1 |
```

使用 C 语言实现, 即:

```c
uint32_t pcnt(uint32_t x) {
    x = (x & 0x55555555) + ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F);
    x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF);
    x = (x & 0x0000FFFF) + ((x >> 16) & 0x0000FFFF);
    return x;
}
```

除此之外有很多其它优化方式和其它算法, 这里不表.

# 前导 0 计数

前导 0 计数也可以利用二分搜索计数实现.

```c
uint32_t clz(uint32_t x) {
    if (x == 0) return(32);
    uint32_t n = 0;
    if (x <= 0x0000FFFF) { n = n + 16; x = x << 16; }
    if (x <= 0x00FFFFFF) { n = n + 8; x = x << 8; }
    if (x <= 0x0FFFFFFF) { n = n + 4; x = x << 4; }
    if (x <= 0x3FFFFFFF) { n = n + 2; x = x << 2; }
    if (x <= 0x7FFFFFFF) { n = n + 1; }
    return n;
}
```

# 后缀 0 计数

计算后缀 0 个数的一种方法是将其转换为求前导 0 计数问题:

```no-highlight
32 - clz(!x & (x - 1))
```
